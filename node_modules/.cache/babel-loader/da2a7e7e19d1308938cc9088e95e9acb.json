{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar pLimit = require('p-limit');\n\nvar EndError = /*#__PURE__*/function (_Error) {\n  _inherits(EndError, _Error);\n\n  var _super = _createSuper(EndError);\n\n  function EndError(value) {\n    var _this;\n\n    _classCallCheck(this, EndError);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  return EndError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // The input can also be a promise, so we `Promise.resolve()` it\n\n\nvar testElement = function testElement(el, tester) {\n  return Promise.resolve(el).then(tester);\n}; // The input can also be a promise, so we `Promise.all()` them both\n\n\nvar finder = function finder(el) {\n  return Promise.all(el).then(function (val) {\n    return val[1] === true && Promise.reject(new EndError(val[0]));\n  });\n};\n\nmodule.exports = function (iterable, tester, opts) {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  var limit = pLimit(opts.concurrency); // Start all the promises concurrently with optional limit\n\n  var items = _toConsumableArray(iterable).map(function (el) {\n    return [el, limit(testElement, el, tester)];\n  }); // Check the promises either serially or concurrently\n\n\n  var checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(function (el) {\n    return checkLimit(finder, el);\n  })).then(function () {}).catch(function (err) {\n    return err instanceof EndError ? err.value : Promise.reject(err);\n  });\n};","map":{"version":3,"sources":["/Users/krunalmehta/React Proj/netflixclonebykrun/netflixclone/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","value","Error","testElement","el","tester","Promise","resolve","then","finder","all","val","reject","module","exports","iterable","opts","Object","assign","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","catch","err"],"mappings":"AAAA;;;;;;;;;;;;AACA,IAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;IAEMC,Q;;;;;AACL,oBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAClB;AACA,UAAKA,KAAL,GAAaA,KAAb;AAFkB;AAGlB;;;iCAJqBC,K,IAOvB;;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,EAAD,EAAKC,MAAL;AAAA,SAAgBC,OAAO,CAACC,OAAR,CAAgBH,EAAhB,EAAoBI,IAApB,CAAyBH,MAAzB,CAAhB;AAAA,CAApB,C,CAEA;;;AACA,IAAMI,MAAM,GAAG,SAATA,MAAS,CAAAL,EAAE;AAAA,SAAIE,OAAO,CAACI,GAAR,CAAYN,EAAZ,EAAgBI,IAAhB,CAAqB,UAAAG,GAAG;AAAA,WAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,IAAX,IAAmBL,OAAO,CAACM,MAAR,CAAe,IAAIZ,QAAJ,CAAaW,GAAG,CAAC,CAAD,CAAhB,CAAf,CAAvB;AAAA,GAAxB,CAAJ;AAAA,CAAjB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,UAACC,QAAD,EAAWV,MAAX,EAAmBW,IAAnB,EAA4B;AAC5CA,EAAAA,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AACpBC,IAAAA,WAAW,EAAEC,QADO;AAEpBC,IAAAA,aAAa,EAAE;AAFK,GAAd,EAGJL,IAHI,CAAP;AAKA,MAAMM,KAAK,GAAGxB,MAAM,CAACkB,IAAI,CAACG,WAAN,CAApB,CAN4C,CAQ5C;;AACA,MAAMI,KAAK,GAAG,mBAAIR,QAAJ,EAAcS,GAAd,CAAkB,UAAApB,EAAE;AAAA,WAAI,CAACA,EAAD,EAAKkB,KAAK,CAACnB,WAAD,EAAcC,EAAd,EAAkBC,MAAlB,CAAV,CAAJ;AAAA,GAApB,CAAd,CAT4C,CAW5C;;;AACA,MAAMoB,UAAU,GAAG3B,MAAM,CAACkB,IAAI,CAACK,aAAL,GAAqB,CAArB,GAAyBD,QAA1B,CAAzB;AAEA,SAAOd,OAAO,CAACI,GAAR,CAAYa,KAAK,CAACC,GAAN,CAAU,UAAApB,EAAE;AAAA,WAAIqB,UAAU,CAAChB,MAAD,EAASL,EAAT,CAAd;AAAA,GAAZ,CAAZ,EACLI,IADK,CACA,YAAM,CAAE,CADR,EAELkB,KAFK,CAEC,UAAAC,GAAG;AAAA,WAAIA,GAAG,YAAY3B,QAAf,GAA0B2B,GAAG,CAAC1B,KAA9B,GAAsCK,OAAO,CAACM,MAAR,CAAee,GAAf,CAA1C;AAAA,GAFJ,CAAP;AAGA,CAjBD","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we `Promise.resolve()` it\nconst testElement = (el, tester) => Promise.resolve(el).then(tester);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(el => [el, limit(testElement, el, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(finder, el)))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n"]},"metadata":{},"sourceType":"script"}